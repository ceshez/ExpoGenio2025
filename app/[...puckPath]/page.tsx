/**
 * This file implements a catch-all route that renders the user-facing pages
 * generated by Puck. For any route visited (with exception of other hardcoded
 * pages in /app), it will check your database (via `getPage`) for a Puck page
 * and render it using <Render>.
 *
 * All routes produced by this page are statically rendered using incremental
 * static site generation. After the first visit, the page will be cached as
 * a static file. Subsequent visits will receive the cache. Publishing a page
 * will invalidate the cache as the page is written in /api/puck/route.ts
 */

// app/[...puckPath]/page.tsx
// app/[...puckPath]/page.tsx
export const runtime = "nodejs";
export const dynamic = "force-dynamic";

import { notFound } from "next/navigation";
import type { Metadata } from "next";
import { Client as Viewer } from "./client";
import { PageModel, type IPage } from "@/lib/mongodb/models/Page";

// Util para sacar un tÃ­tulo desde el contenido de Puck (fallback)
function titleFromContent(content: any): string | undefined {
  try {
    return content?.root?.props?.title;
  } catch {
    return undefined;
  }
}

export async function generateMetadata({
  params,
}: {
  params: Promise<{ puckPath?: string[] }>;
}): Promise<Metadata> {
  // ðŸ‘‡ En tu proyecto, params es Promise. Â¡Siempre await!
  const { puckPath = [] } = await params;
  const path = `/${puckPath.join("/")}`;

  const Pages = await PageModel();
  const rec = (await Pages.findOne(
    { path, isDeleted: { $ne: true } },
    { _id: 0, title: 1, content: 1, data: 1 }
  ).lean()) as Pick<IPage, "title" | "content"> & { data?: any } | null;

  const content = rec?.content ?? (rec as any)?.data;
  const fallbackTitle = titleFromContent(content) ?? "Genio";

  return {
    title: rec?.title ?? fallbackTitle,
  };
}

export default async function Page({
  params,
}: {
  params: Promise<{ puckPath?: string[] }>;
}) {
  // ðŸ‘‡ Igual aquÃ­: await params antes de usar puckPath
  const { puckPath = [] } = await params;
  const path = `/${puckPath.join("/")}`;

  const Pages = await PageModel();
  const rec = (await Pages.findOne(
    { path, isDeleted: { $ne: true } },
    { _id: 0, content: 1, data: 1 }
  ).lean()) as Pick<IPage, "content"> & { data?: any } | null;

  // Preferimos `content`, pero soportamos docs antiguos con `data`
  const content = rec?.content ?? rec?.data;
  if (!content) return notFound();

  // Asegurar objeto plano (evitar prototipos de Mongoose)
  const safe = JSON.parse(JSON.stringify(content));

  return <Viewer data={safe as any} />;
}

